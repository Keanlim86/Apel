<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Receipt Scanner</title>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- PDF.js library for rendering PDFs to canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .upload-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9ff;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            background: #e8ebff;
            border-color: #764ba2;
        }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: 600;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #imagePreview {
            max-width: 100%;
            border-radius: 10px;
            display: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .progress-container {
            display: none;
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .results-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .info-card {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .info-card h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        tr:hover {
            background: #f8f9ff;
        }

        .total-row {
            font-weight: bold;
            background: #f0f2ff;
            font-size: 1.2em;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .btn-secondary:hover {
            background: #f8f9ff;
        }

        #results {
            display: none;
        }

        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìÑ Receipt Scanner</h1>
            <p>Upload a receipt image and extract data automatically</p>
        </div>

        <div class="content">
            <div class="upload-section">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üì∏</div>
                    <h3>Drop receipt image or PDF here</h3>
                    <p>or click to select file</p>
                    <input type="file" id="fileInput" accept="image/*,application/pdf" style="display: none;">
                </div>
                
                <img id="imagePreview" alt="Receipt preview">
                
                <button class="btn" id="scanBtn" style="display: none;">Scan Receipt</button>
                
                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                </div>

                <!-- On-screen debug panel (visible when debugging) -->
                <div id="debugPanel" style="display:none; background:#111; color:#e6e6e6; padding:12px; border-radius:8px; margin-top:16px; max-height:240px; overflow:auto; font-family: monospace; font-size:13px;">
                    <strong>Debug:</strong>
                    <pre id="debugText" style="white-space:pre-wrap; margin-top:8px;"></pre>
                </div>
            </div>

            <div class="results-section" id="results">
                <div class="info-card">
                    <h3>Merchant</h3>
                    <p id="merchant">-</p>
                </div>
                
                <div class="info-card">
                    <h3>Date</h3>
                    <p id="date">-</p>
                </div>

                <div>
                    <h3 style="margin-bottom: 10px; color: #667eea;">Items</h3>
                    <table id="itemsTable">
                        <thead>
                            <tr>
                                <th>Item</th>
                                <th>Price</th>
                            </tr>
                        </thead>
                        <tbody id="itemsBody"></tbody>
                    </table>
                </div>

                <div class="export-buttons">
                    <button class="btn btn-secondary" id="exportSummaryExcel">Export Summary Excel</button>
                    <button class="btn btn-secondary" id="exportExcel">Export Full Excel</button>
                    <button class="btn btn-secondary" id="exportSummaryCSV">Export Summary CSV</button>
                    <button class="btn btn-secondary" id="exportCSV">Export Full CSV</button>
                    <button class="btn btn-secondary" id="copyTable">Copy Table</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentImage = null;
        let receiptData = null;

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const imagePreview = document.getElementById('imagePreview');
        const scanBtn = document.getElementById('scanBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const results = document.getElementById('results');
        const processingCanvas = document.createElement('canvas');
        processingCanvas.id = 'processingCanvas';
        processingCanvas.style.display = 'none';
        document.body.appendChild(processingCanvas);
        const processingCtx = processingCanvas.getContext('2d');

        // Upload area click
        uploadArea.addEventListener('click', () => fileInput.click());

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && (file.type.startsWith('image/') || file.type === 'application/pdf')) {
                handleFile(file);
            }
        });

        // File input change
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        async function handleFile(file) {
            if (file.type === 'application/pdf') {
                await handlePDF(file);
            } else {
                handleImage(file);
            }
        }

        function handleImage(file) {
            currentImage = file;
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
                scanBtn.style.display = 'block';
            };
            reader.readAsDataURL(file);
        }

        async function handlePDF(file) {
            try {
                // Check if PDF.js is loaded
                if (typeof pdfjsLib === 'undefined') {
                    alert('PDF library is still loading. Please try again in a moment.');
                    return;
                }
                
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                
                // Get first page
                const page = await pdf.getPage(1);
                const viewport = page.getViewport({ scale: 3.0 });
                
                // Create canvas
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                // Render PDF page to canvas
                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;
                
                // Auto-crop the receipt region and enhance for OCR accuracy
                const enhancedCanvas = autoCropAndEnhance(canvas, 2000);
                const blob = await new Promise(resolve => enhancedCanvas.toBlob(resolve, 'image/png'));
                currentImage = blob;
                const infoMsg = 'PDF rendered and enhanced to blob, size: ' + (blob ? blob.size : 'none') + ' enhanced dims: ' + enhancedCanvas.width + ' x ' + enhancedCanvas.height;
                console.log(infoMsg);
                setDebug(infoMsg);
                imagePreview.src = enhancedCanvas.toDataURL();
                imagePreview.style.display = 'block';
                scanBtn.style.display = 'block';
                
            } catch (error) {
                alert('Error loading PDF: ' + error.message);
                console.error('PDF Error:', error);
            }
        }

        async function prepareProcessingCanvas(source) {
            if (!source) throw new Error('No image source provided for processing canvas');

            const isCanvasSource = source instanceof HTMLCanvasElement;
            if (isCanvasSource) {
                processingCanvas.width = source.width;
                processingCanvas.height = source.height;
                processingCtx.clearRect(0, 0, source.width, source.height);
                processingCtx.drawImage(source, 0, 0);
            } else {
                const objectUrl = URL.createObjectURL(source);
                const img = new Image();
                const loadPromise = new Promise((resolve, reject) => {
                    img.onload = () => resolve();
                    img.onerror = () => reject(new Error('Failed to load image for processing canvas'));
                });
                img.src = objectUrl;
                try {
                    await loadPromise;
                } finally {
                    URL.revokeObjectURL(objectUrl);
                }

                processingCanvas.width = img.width;
                processingCanvas.height = img.height;
                processingCtx.clearRect(0, 0, img.width, img.height);
                processingCtx.drawImage(img, 0, 0);
            }

            const cropped = autoCropAndEnhance(processingCanvas, 2000);
            const processed = preprocessCanvas(cropped);
            appendDebug('Processing canvas ready (' + processed.width + ' x ' + processed.height + ')');
            return processed;
        }

        // Scan button
        scanBtn.addEventListener('click', scanReceipt);

        async function scanReceipt() {
            if (!currentImage) {
                setDebug('No image available to scan.');
                return;
            }

            setDebug('Starting scan...');
            appendDebug('Image size: ' + ((currentImage && currentImage.size) ? currentImage.size : 'n/a'));

            // Quick check that Tesseract is available
            if (typeof Tesseract === 'undefined') {
                appendDebug('Tesseract.js not loaded.');
                alert('OCR library not ready. Please refresh the page and try again.');
                return;
            }

            scanBtn.disabled = true;
            progressContainer.style.display = 'block';
            results.style.display = 'none';

            try {
                let ocrSource = currentImage;
                try {
                    ocrSource = await prepareProcessingCanvas(currentImage);
                } catch (prepError) {
                    appendDebug('Processing canvas prep failed, falling back to raw image: ' + prepError.message);
                }

                const result = await Tesseract.recognize(ocrSource, 'eng', {
                    logger: (m) => {
                        // Update progress bar and debug panel
                        if (m.status === 'recognizing text') {
                            const progress = Math.round(m.progress * 100);
                            progressFill.style.width = progress + '%';
                            progressFill.textContent = progress + '%';
                            appendDebug('OCR progress: ' + progress + '%');
                        } else {
                            appendDebug('OCR status: ' + m.status + (m.progress ? (' ' + Math.round(m.progress * 100) + '%') : ''));
                        }
                    },
                    tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz .,/$-:',
                    tessedit_pageseg_mode: Tesseract.PSM.AUTO
                });

                appendDebug('OCR raw text: ' + (result && result.data ? result.data.text : ''));
                const text = cleanOCRText(result.data.text);
                appendDebug('OCR cleaned text: ' + text);
                receiptData = parseReceipt(text);
                appendDebug('Parsed receipt: ' + JSON.stringify(receiptData));
                displayResults(receiptData);

            } catch (error) {
                appendDebug('Error scanning receipt: ' + (error && error.message ? error.message : JSON.stringify(error)));
                alert('Error scanning receipt: ' + error.message);
            } finally {
                scanBtn.disabled = false;
            }
        }

        function cleanOCRText(text) {
            // Remove common OCR artifacts and special characters
            text = text.replace(/[^\x00-\x7F]/g, ''); // Remove non-ASCII
            text = text.replace(/√Ç¬•|√Ç¬´|√Ç¬ª|√Ç¬Æ|√Ç¬©|√Ç¬∞/g, ''); // Remove specific artifacts
            text = text.replace(/[|~`^]/g, ''); // Remove confusing symbols
            
            // Fix common OCR letter confusion for Singapore merchants
            // Isetan
            text = text.replace(/\bT SINGAPORE\b/gi, 'ISETAN SINGAPORE');
            text = text.replace(/\bTSETAN\b/gi, 'ISETAN');
            text = text.replace(/\b1SETAN\b/gi, 'ISETAN');
            text = text.replace(/\bISETAN\b/gi, 'ISETAN');
            
            // FairPrice variations
            text = text.replace(/\bFa1rpr1ce\b/gi, 'FAIRPRICE');
            text = text.replace(/\bFa1rprice\b/gi, 'FAIRPRICE');
            text = text.replace(/\bFairpr1ce\b/gi, 'FAIRPRICE');
            text = text.replace(/\bFair Pr1ce\b/gi, 'FAIRPRICE');
            text = text.replace(/\bNTUC\s*Fa1rprice\b/gi, 'NTUC FAIRPRICE');
            
            // Cold Storage
            text = text.replace(/\bC0LD\s*ST0RAGE\b/gi, 'COLD STORAGE');
            text = text.replace(/\bC0LDSTORAGE\b/gi, 'COLD STORAGE');
            text = text.replace(/\bCOLD\s*ST0RAGE\b/gi, 'COLD STORAGE');
            text = text.replace(/\bC0LD\s*STORAGE\b/gi, 'COLD STORAGE');
            
            // Giant
            text = text.replace(/\bG1ANT\b/gi, 'GIANT');
            text = text.replace(/\bGlANT\b/gi, 'GIANT');
            
            // Sheng Siong
            text = text.replace(/\bSHENG\s*S10NG\b/gi, 'SHENG SIONG');
            text = text.replace(/\bSHENG\s*SlONG\b/gi, 'SHENG SIONG');
            
            // Prime / Cheers / 7-Eleven
            text = text.replace(/\bPR1ME\b/gi, 'PRIME');
            text = text.replace(/\bCHEERS\b/gi, 'CHEERS');
            text = text.replace(/\b7-ELEVEN\b/gi, '7-ELEVEN');
            text = text.replace(/\b7-ELEVEtl\b/gi, '7-ELEVEN');
            text = text.replace(/\b7\s*ELEVEN\b/gi, '7-ELEVEN');
            
            // Don Don Donki
            text = text.replace(/\bD0N\s*D0N\s*D0NKI\b/gi, 'DON DON DONKI');
            text = text.replace(/\bDON\s*DON\s*D0NKI\b/gi, 'DON DON DONKI');
            text = text.replace(/\bD0NK1\b/gi, 'DONKI');
            
            // Guardian / Watsons
            text = text.replace(/\bGUARD1AN\b/gi, 'GUARDIAN');
            text = text.replace(/\bWATS0NS\b/gi, 'WATSONS');
            text = text.replace(/\bWATSONS\b/gi, 'WATSONS');
            
            // Popular / Courts
            text = text.replace(/\bP0PULAR\b/gi, 'POPULAR');
            text = text.replace(/\bC0URTS\b/gi, 'COURTS');
            
            // McDonald's / KFC / Burger King
            text = text.replace(/\bMcD0NALD'?S\b/gi, 'MCDONALDS');
            text = text.replace(/\bMCDONALD'?S\b/gi, 'MCDONALDS');
            text = text.replace(/\bKFC\b/gi, 'KFC');
            text = text.replace(/\bBURGER\s*K1NG\b/gi, 'BURGER KING');
            
            // Uniqlo / Muji / Daiso
            text = text.replace(/\bUN1QLO\b/gi, 'UNIQLO');
            text = text.replace(/\bUNIQL0\b/gi, 'UNIQLO');
            text = text.replace(/\bMUJ1\b/gi, 'MUJI');
            text = text.replace(/\bDA1SO\b/gi, 'DAISO');
            text = text.replace(/\bDAIS0\b/gi, 'DAISO');
            
            // Try to fix chunked text by detecting price patterns and adding line breaks
            // Add line break before prices that look like: 1.23 or $1.23 or 12.34
            text.replace(/(\d+\.\d{2})(?=\s+[A-Z])/g, '$1\n');
            
            // Add line break before common quantity patterns: 1pcs, 2x, 1kg
            text = text.replace(/\s+(\d+(?:pcs|pc|x|kg|g|ml|l)\b)/gi, '\n$1 ');
            
            // Add line break before "Description" and similar headers
            text = text.replace(/(Description|Item|Product|Qty)/gi, '\n$1');
            
            // Add line break before parentheses that often indicate new items
            text = text.replace(/\)\s+([A-Z])/g, ')\n$1');
            
            // Normalize multiple spaces but preserve line breaks
            text = text.replace(/ +/g, ' ');
            text = text.replace(/\n\s+/g, '\n');
            
            return text;
        }

        function normalizeMerchant(merchant, fullText) {
            // Normalize common merchant OCR variants using heuristics
            const t = (fullText || '').toUpperCase();
            let normalized = merchant;

            // ISETAN variants seen in OCR: ISETAN, TSETAN, 1SETAN, IBETAN, IBETaN (from PDFs)
            if (/ISETAN|TSETAN|1SETAN|IBETAN|I\s*B\s*E\s*T\s*A\s*N/gi.test(t)) {
                normalized = /SINGAPORE/i.test(t) ? 'ISETAN SINGAPORE' : 'ISETAN';
            }

            // If merchant was just 'SINGAPORE' but text contains ISETAN-like tokens, prefer the full name
            if (/^SINGAPORE$/i.test(merchant) && /ISETAN|TSETAN|1SETAN|IBETAN/i.test(t)) {
                normalized = 'ISETAN SINGAPORE';
            }

            if (normalized !== merchant) console.log('Merchant normalized from', merchant, 'to', normalized);
            return normalized;
        }

        function parseReceipt(text) {
            let lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 2);

            let items = [];
            let total = 0;
            let subtotal = 0;
            let gst = 0;
            let date = '';
            let merchant = '';

            // -------------------------------
            // 1Ô∏è‚É£ Find merchant (first 5 lines, mostly letters)
            // -------------------------------
            for (let i = 0; i < Math.min(5, lines.length); i++) {
                const line = lines[i];
                const letterCount = (line.match(/[a-zA-Z]/g) || []).length;
                const digitCount = (line.match(/\d/g) || []).length;
                if (letterCount > 3 && letterCount > digitCount * 2) {
                    merchant = line;
                    break;
                }
            }

            // -------------------------------
            // 2Ô∏è‚É£ Find date
            // -------------------------------
            const datePatterns = [
                /\b(\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4})\b/,
                /\b(\d{4}[-\/]\d{1,2}[-\/]\d{1,2})\b/,
                /\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2},?\s+\d{4}\b/i,
                /Date[:\s]*(\d{1,2}\/\d{1,2}\/\d{2,4})/i
            ];
            const fallbackDatePattern = /(\d{2})(\d{2})(\d{2,4})/; // DD MM YY(YY)
            
            for (const line of lines) {
                for (const pattern of datePatterns) {
                    const match = line.match(pattern);
                    if (match) {
                        date = match[1] || match[0];
                        break;
                    }
                }
                if (date) break;
                
                // Fallback: remove all non-digit characters
                const digitOnlyLine = line.replace(/\D/g, ''); 
                const matchDigitSeq = digitOnlyLine.match(/\d{8,10}/); // first 8-10 digit sequence
                
                if (matchDigitSeq) {
                    const digits = matchDigitSeq[0]; // e.g. "237472026" or "23042026"    
                    const matchFallback = digitOnlyLine.match(fallbackDatePattern);     
                    if (matchFallback) {
                        let d = parseInt(matchFallback[1], 10);
                        let m = parseInt(matchFallback[2], 10);
                        let y = parseInt(matchFallback[3], 10);
                        
                        // OCR correction rules: swap 7 ‚Üî 0 if month > 12
                        if (m > 12 && m < 32) m = parseInt(matchFallback[2].replace('7','0'), 10);

                        // Handle 2-digit year
                        if (y < 100) y += 2000;

                        // Only accept valid date
                        if (d >=1 && d <= 31 && m >=1 && m <=12 && y > 2000 && y < 2100) {
                            // Pad day and month to 2 digits
                            date = `${d.toString().padStart(2,'0')}/${m.toString().padStart(2,'0')}/${y}`;
                        }
                    }
                }
            }

            // -------------------------------
            // Helper: detect if receipt uses quantity markers
            // -------------------------------
            function usesQtyPattern(lines) {
                const qtyPattern = /^\s*(\d+)\s*(x|no\.?)\s+/i;
                const ocrQtyPattern = /^\s*[1lI|O0]+\s*[xX]\s+/; // OCR variants: I/l/| for 1, O for 0
                return lines.some(line => qtyPattern.test(line) || ocrQtyPattern.test(line));
            }

            // -------------------------------
            // Helper: parse items with qty markers
            // -------------------------------
            function parseQtyMarkerItems(lines) {
                const qtyPattern = /^\s*(\d+)\s*(x|no\.?)\s+(.*)/i;
                const ocrQtyPattern = /^\s*([1lI|O0]+)\s*([xX])\s+(.*)/i; // OCR-tolerant qty pattern; groups: qty, x, name
                const pricePattern = /\$?\s*(\d+\.\d{2})\b/;
                const parsedItems = [];

                for (let i = 0; i < lines.length; i++) {
                    let match = lines[i].match(qtyPattern);
                    if (!match) match = lines[i].match(ocrQtyPattern); // fallback to OCR variant
                    if (match) {
                        const qty = parseInt(match[1].replace(/[lI|]/g, '1').replace(/O/g, '0'), 10); // normalize OCR chars
                        let itemName = (match[3] || '').trim();

                        // Price may be on same line or next line
                        let price = 0;
                        const priceMatch = lines[i].match(pricePattern) || (i + 1 < lines.length && lines[i + 1].match(pricePattern));
                        if (priceMatch) {
                            price = parseFloat(priceMatch[1].replace(',', '.'));
                        }

                        // Multiply price by qty if desired
                        parsedItems.push({ name: cleanItemName(itemName), price });
                    }
                }

                return parsedItems;
            }

            // -------------------------------
            // üÜï Helper function to extract prices with spaces
            // -------------------------------

            function extractPriceFromLine(line) {
                if (!line) return null;
                // Use global patterns and prefer the last full match on the line.
                const spacedRe = /\$?\s*(\d+)\s*\.\s*(\d{2})(?!\d)/g; // avoid matching 0.783 as 0.78
                const standardRe = /\$?\s*(\d+\.\d{2})(?!\d)/g;

                const spacedMatches = [...line.matchAll(spacedRe)];
                if (spacedMatches.length > 0) {
                    const m = spacedMatches[spacedMatches.length - 1];
                    return parseFloat(m[1] + '.' + m[2]);
                }

                const stdMatches = [...line.matchAll(standardRe)];
                if (stdMatches.length > 0) {
                    const m = stdMatches[stdMatches.length - 1];
                    return parseFloat(m[1].replace(',', '.'));
                }

                return null;
            }

            // -------------------------------
            // 3Ô∏è‚É£ Parse items and prices
            // -------------------------------
            const pricePattern = /\$?\s*(\d+\.\d{2})\b/g;
            const spacedPricePattern = /\$?\s*\d+\s*\.\s*\d{2}\b/g; // matches spaced prices like "6. 30"
            const subtotalPattern = /\bsub[\s-]?to?t?a?l\b/i; // fuzzy subtotal
            const subtotalVariants = /\b(subfotal|subtatal|subt0tal|sub-total)\b/i;
            const totalPattern = /\btotal\b/i;
            const taxPattern = /\b(G[S5]T|G5T|GST|65T|included|incl|Inc\.\s*9%\s*GST|GST\s*9%)\b/i; // fuzzy GST/tax

            // Better fuzzy detection for 'subtotal' to catch OCR variants like 'subiotal'
            function levenshtein(a, b) {
                if (a === b) return 0;
                const al = a.length, bl = b.length;
                if (al === 0) return bl;
                if (bl === 0) return al;
                const matrix = Array.from({ length: al + 1 }, () => new Array(bl + 1));
                for (let i = 0; i <= al; i++) matrix[i][0] = i;
                for (let j = 0; j <= bl; j++) matrix[0][j] = j;
                for (let i = 1; i <= al; i++) {
                    for (let j = 1; j <= bl; j++) {
                        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j - 1] + cost
                        );
                    }
                }
                return matrix[al][bl];
            }

            function isLikelySubtotal(line) {
                if (!line) return false;
                // quick regex catches
                if (subtotalPattern.test(line) || subtotalVariants.test(line)) return true;
                // token-wise fuzzy check
                const tokens = line.split(/\s|[:\-]/).map(t => t.replace(/[^a-zA-Z]/g, '').toLowerCase()).filter(Boolean);
                for (const t of tokens) {
                    if (t.length < 4) continue;
                    const dist = levenshtein(t, 'subtotal');
                    if (dist <= 2) return true;
                }
                return false;
            }

            if (usesQtyPattern(lines)) {
                // Use qty marker parser
                items = parseQtyMarkerItems(lines);

                // Scan for subtotal, total, and GST after parsing items
                for (let line of lines) {
                    const lowerLine = line.toLowerCase();
                    const matches = [...line.matchAll(pricePattern)];
                    if (matches.length === 0) continue;
                    const price = parseFloat(matches[matches.length - 1][1].replace(',', '.'));

                    if (taxPattern.test(lowerLine)) {
                        gst = price;
                    } else if (isLikelySubtotal(lowerLine)) {
                        if (!subtotal) subtotal = price;
                    } else if (totalPattern.test(lowerLine) && !isLikelySubtotal(lowerLine)) {
                        total = price;
                    }
                }
            } else {
                // Existing parser branch
                let skipNext = false;

                for (let i = 0; i < lines.length; i++) {
                    if (skipNext) {
                        skipNext = false;
                        continue;
                    }

                    const line = lines[i];
                    const lowerLine = line.toLowerCase();

                    // Skip headers/footers
                    if (/(tel:|reg\.?\s*no|gst\s*reg|staff:|slip:|pos )/i.test(lowerLine)) continue;

                    // Prefer extractPriceFromLine which handles spaced prices like "6. 30"
                    let price = extractPriceFromLine(line);
                    let matches = [];
                    if (price === null) {
                        matches = [...line.matchAll(pricePattern)];
                        if (matches.length > 0) {
                            price = parseFloat(matches[matches.length - 1][1].replace(',', '.'));
                        }
                    }

                    const hasPrice = price !== null;

                    // Handle split items: current line no price, next line has price
                    if (!hasPrice && i < lines.length - 1) {
                        const nextLine = lines[i + 1];
                        const nextPrice = extractPriceFromLine(nextLine);
                        if (nextPrice !== null) {
                            // Heuristic: only attach next-line price when current line looks like an item
                            const candidate = line;
                            const letterCount = (candidate.match(/[a-zA-Z]/g) || []).length;
                            const digitCount = (candidate.match(/\d/g) || []).length;
                            const lowerCandidate = candidate.toLowerCase();

                            // Reject obvious metadata lines containing long numeric sequences after ':' or keywords
                            const hasColonNumber = /:\s*\d{3,}/.test(candidate);
                            const isMeta = /^(order|repis|receipt|pax|pos|gst|uen|closed|payment|invoice|tax|tel)\b/i.test(lowerCandidate) || /repis|order|receipt|pax|pos|gst|uen|closed|payment|invoice|tax|tel/.test(lowerCandidate);

                            // Candidate should have sufficient letters and not be dominated by digits
                            const looksLikeItem = letterCount > 2 && (digitCount / Math.max(1, candidate.length)) < 0.3 && !hasColonNumber && !isMeta;

                            if (looksLikeItem) {
                                price = nextPrice;
                                let itemName = candidate.replace(/^\s*\d+\s*(?:x|pcs|pc)?\s*/i, '').replace(/\d+\.?\d*\s*(pcs|pc|x|kg|g|ml|l|pkt)?/gi, '').trim();
                                if (itemName && price >= 0) {
                                    items.push({ name: cleanItemName(itemName), price });
                                    skipNext = true;
                                    continue;
                                }
                            }
                        }
                    }

                    if (hasPrice) {
                        // price variable already set (either spaced pattern or regex)

                        // GST / tax
                        if (taxPattern.test(lowerLine)) {
                            gst = price;
                            continue;
                        }

                        // Subtotal (only set on first match to avoid duplicates)
                        if (isLikelySubtotal(lowerLine)) {
                            if (!subtotal) subtotal = price;
                            continue;
                        }

                        // Total
                        if (totalPattern.test(lowerLine) && !subtotalPattern.test(lowerLine)) {
                            total = price;
                            continue;
                        }

                        // Skip non-item lines
                        if (/(tax|change|cash|card|tender)/i.test(lowerLine)) continue;

                        // Add as item - remove any spaced or normal price tokens first
                        let itemLineClean = line.replace(spacedPricePattern, '').replace(pricePattern, '');
                        let itemName = itemLineClean.replace(/^\s*\d+\s*(?:x|pcs|pc)?\s*/i, '').replace(/\d+\.?\d*\s*(pcs|pc|x|kg|g|ml|l|pkt)?/gi, '').trim();
                        if (itemName && price >= 0) {
                            const digitRatio = (itemName.match(/\d/g) || []).length / itemName.length;
                            if (digitRatio < 0.7) {
                                // Remove leading and trailing numbers or non-letter characters
                                let cleanName = itemName.replace(/^[^a-zA-Z]+|[^a-zA-Z]+$/g, '').trim();

                                if (cleanName.length > 0) {
                                    items.push({ name: cleanItemName(cleanName), price });
                                }
                            }
                        }
                    }
                }
            }

            // -------------------------------
            // 4Ô∏è‚É£ Ensure total is reasonable (consistent with displayResults)
            // -------------------------------
            const itemsSum = items.reduce((sum, item) => sum + item.price, 0);

            // Start with the parsed total
            let finalTotal = total;

            // If no total is found, use subtotal if reasonable, else sum of items
            if (!finalTotal) {
                if (subtotal && subtotal >= itemsSum) finalTotal = subtotal;
                else finalTotal = itemsSum;
            } else {
                // Total exists: check against itemsSum
                if (finalTotal < itemsSum) {
                    // If total is smaller than sum of items, prefer subtotal if available and sufficient
                    if (subtotal && subtotal >= itemsSum) finalTotal = subtotal;
                    else finalTotal = itemsSum;
                } else if (finalTotal > itemsSum + 0.01) {
                    // Total is larger than items sum, keep it but could log/debug
                    // optional: appendDebug(`Total (${finalTotal.toFixed(2)}) larger than sum of items (${itemsSum.toFixed(2)})`);
                }
            }

            // -------------------------------
            // 5Ô∏è‚É£ Normalize merchant
            // -------------------------------
            merchant = normalizeMerchant(merchant, text);

            return { merchant, date, items, subtotal, gst, total };
        }

        function cleanItemName(itemName) {
            // Remove SKU numbers (patterns like: 123456, 12-3456, SKU123456, #123456)
            itemName = itemName.replace(/\d{5,}[^\s]*/g, '') // Remove digits + everything until space
            itemName = itemName.replace(/\b\d{5,}\b/g, ''); // 5+ consecutive digits
            itemName = itemName.replace(/\b\d{2,}-\d{2,}\b/g, ''); // Format like 12-3456
            itemName = itemName.replace(/\bsku\s*:?\s*\d+/gi, ''); // SKU: 123456
            itemName = itemName.replace(/\b#\d{4,}\b/g, ''); // #123456
            itemName = itemName.replace(/\bitem\s*:?\s*\d+/gi, ''); // Item: 123456
            itemName = itemName.replace(/\bcode\s*:?\s*\d+/gi, ''); // Code: 123456
            // Remove price-like tokens (e.g. $10.80, 10. 80, 10,80) left in item text
            itemName = itemName.replace(/\$?\s*\d+\s*[\.,]\s*\d{2}\b/g, '');
            // Remove stray currency symbols or multiple dots left behind
            itemName = itemName.replace(/\$/g, '');
            itemName = itemName.replace(/\.{2,}/g, '');

            
            // Clean up item name - only remove specific leading/trailing characters
            // Keep parentheses, but remove dashes, underscores, asterisks at start/end
            itemName = itemName.replace(/^[-_*.\s]+|[-_*.\s]+$/g, '');
            itemName = itemName.replace(/\s+/g, ' '); // Normalize spaces
            itemName = itemName.trim();
            
            return itemName;
        }

        // Auto-crop small receipt regions and enhance contrast before OCR
        function autoCropAndEnhance(sourceCanvas, targetWidth = 2000) {
            const sw = sourceCanvas.width, sh = sourceCanvas.height;
            const ctx = sourceCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, sw, sh);
            const data = imageData.data;

            // Find bounding box of non-white pixels (sample every 3 pixels for speed)
            let minX = sw, minY = sh, maxX = 0, maxY = 0;
            const sample = 3;
            const threshold = 240; // brightness threshold (0-255)

            for (let y = 0; y < sh; y += sample) {
                for (let x = 0; x < sw; x += sample) {
                    const i = (y * sw + x) * 4;
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                    if (lum < threshold) {
                        if (x < minX) minX = x;
                        if (y < minY) minY = y;
                        if (x > maxX) maxX = x;
                        if (y > maxY) maxY = y;
                    }
                }
            }

            // If nothing detected, return original canvas
            if (maxX === 0 && maxY === 0) {
                console.log('autoCropAndEnhance: no content detected; skipping crop.');
                return sourceCanvas;
            }

            // Add padding
            const padding = Math.round(Math.min(sw, sh) * 0.03) + 20;
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(sw, maxX + padding);
            maxY = Math.min(sh, maxY + padding);

            const cw = maxX - minX;
            const ch = maxY - minY;

            // Determine scale to reach targetWidth (but cap to avoid huge canvases)
            const capWidth = 3000; // increase cap to allow better upscaling if needed
            let scale = 1;
            if (cw > 0 && cw < targetWidth) scale = targetWidth / cw;
            const dw = Math.min(Math.round(cw * scale), capWidth);
            const dh = Math.round(ch * (dw / cw));

            const dest = document.createElement('canvas');
            dest.width = dw;
            dest.height = dh;
            const dctx = dest.getContext('2d');
            dctx.imageSmoothingEnabled = true;
            dctx.imageSmoothingQuality = 'high';

            // Apply simple enhancements: make grayscale and boost contrast slightly
            dctx.filter = 'grayscale(100%) contrast(120%)';
            dctx.drawImage(sourceCanvas, minX, minY, cw, ch, 0, 0, dw, dh);
            dctx.filter = 'none';

            console.log('autoCropAndEnhance: cropped to', cw, 'x', ch, 'and scaled to', dw, 'x', dh);
            return dest;
        }

        // Preprocessing: sharpen and binarize to improve OCR accuracy for low-res receipts
        function preprocessCanvas(canvas) {
            const w = canvas.width, h = canvas.height;
            const ctx = canvas.getContext('2d');
            let imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;

            // Convert to grayscale
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                const l = Math.round(0.2126*r + 0.7152*g + 0.0722*b);
                data[i] = data[i+1] = data[i+2] = l;
            }

            // Apply simple sharpen filter via convolution kernel
            const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
            const output = new Uint8ClampedArray(data.length);
            for (let y = 1; y < h-1; y++) {
                for (let x = 1; x < w-1; x++) {
                    let sum = 0;
                    let ki = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const px = x + kx;
                            const py = y + ky;
                            const idx = (py * w + px) * 4;
                            sum += data[idx] * kernel[ki++];
                        }
                    }
                    const dstIdx = (y * w + x) * 4;
                    const v = Math.max(0, Math.min(255, sum));
                    output[dstIdx] = output[dstIdx+1] = output[dstIdx+2] = v;
                    output[dstIdx+3] = 255;
                }
            }

            // Copy edges if any (simple copy to avoid zeros)
            for (let x = 0; x < w; x++) {
                const top = x * 4;
                const bottom = ((h-1) * w + x) * 4;
                output[top] = data[top]; output[top+1] = data[top+1]; output[top+2] = data[top+2]; output[top+3] = 255;
                output[bottom] = data[bottom]; output[bottom+1] = data[bottom+1]; output[bottom+2] = data[bottom+2]; output[bottom+3] = 255;
            }
            for (let y = 0; y < h; y++) {
                const left = (y * w) * 4;
                const right = (y * w + (w-1)) * 4;
                output[left] = data[left]; output[left+1] = data[left+1]; output[left+2] = data[left+2]; output[left+3] = 255;
                output[right] = data[right]; output[right+1] = data[right+1]; output[right+2] = data[right+2]; output[right+3] = 255;
            }

            // Put sharpened data back
            imgData.data.set(output);

            // Compute global Otsu threshold
            const histogram = new Array(256).fill(0);
            for (let i = 0; i < output.length; i += 4) histogram[output[i]]++;
            const total = w * h;
            let sum = 0;
            for (let t = 0; t < 256; t++) sum += t * histogram[t];
            let sumB = 0;
            let wB = 0;
            let maxVar = 0;
            let threshold = 128;
            for (let t = 0; t < 256; t++) {
                wB += histogram[t];
                if (wB === 0) continue;
                const wF = total - wB;
                if (wF === 0) break;
                sumB += t * histogram[t];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                const varBetween = wB * wF * Math.pow(mB - mF, 2);
                if (varBetween > maxVar) {
                    maxVar = varBetween;
                    threshold = t;
                }
            }

            // Apply threshold
            for (let i = 0; i < output.length; i += 4) {
                const v = output[i] >= threshold ? 255 : 0;
                output[i] = output[i+1] = output[i+2] = v;
                output[i+3] = 255;
            }

            imgData.data.set(output);
            ctx.putImageData(imgData, 0, 0);

            console.log('preprocessCanvas: applied sharpen + otsu threshold (t=' + threshold + ')');
            return canvas;
        }

        // Debug helpers
        function setDebug(msg) {
            const panel = document.getElementById('debugPanel');
            const text = document.getElementById('debugText');
            if (!panel || !text) return;
            panel.style.display = 'block';
            text.textContent = msg;
        }

        function appendDebug(msg) {
            const panel = document.getElementById('debugPanel');
            const text = document.getElementById('debugText');
            if (!panel || !text) return;
            panel.style.display = 'block';
            text.textContent += (text.textContent ? '\n' : '') + msg;
        }

        function displayResults(data) {
            document.getElementById('merchant').textContent = data.merchant;
            document.getElementById('date').textContent = data.date;

            const tbody = document.getElementById('itemsBody');
            tbody.innerHTML = '';

            data.items.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = item.name;
                row.insertCell(1).textContent = '$' + item.price.toFixed(2);
            });

            // Subtotal  (Optional)
            if (data.subtotal && data.subtotal > 0) {
                const subRow = tbody.insertRow();
                subRow.insertCell(0).textContent = 'Subtotal';
                subRow.insertCell(1).textContent = '$' + data.subtotal.toFixed(2);
            }

            // GST (Optional)
            if (data.gst && data.gst > 0) {
                const gstRow = tbody.insertRow();
                gstRow.insertCell(0).textContent = 'GST';
                gstRow.insertCell(1).textContent = '$' + data.gst.toFixed(2);
            }

            // 4Ô∏è‚É£ Calculate sum of items
            const itemsSum = data.items.reduce((sum, it) => sum + it.price, 0);
           
            // Decide final total for display
            let displayTotal = data.total;

            if (displayTotal < itemsSum) {
                // If total is less than items sum, prefer subtotal if available
                if (data.subtotal && data.subtotal >= itemsSum) {
                    displayTotal = data.subtotal;
                    appendDebug(`Total (${data.total.toFixed(2)}) was less than sum of items (${itemsSum.toFixed(2)}), using subtotal (${data.subtotal.toFixed(2)}) instead.`);
                } else {
                    displayTotal = itemsSum;
                    appendDebug(`Total (${data.total.toFixed(2)}) was less than sum of items (${itemsSum.toFixed(2)}), using sum of items instead.`);
                }
            } else if (displayTotal > itemsSum + 0.01) {
                // If total is larger than items sum, just notify
                appendDebug(`Total (${displayTotal.toFixed(2)}) is larger than sum of items (${itemsSum.toFixed(2)}).`);
            }

            // Update table with final total
            const totalRow = tbody.insertRow();
            totalRow.className = 'total-row';
            totalRow.insertCell(0).textContent = 'TOTAL';
            totalRow.insertCell(1).textContent = '$' + displayTotal.toFixed(2);

            results.style.display = 'flex';
            progressContainer.style.display = 'none';
        }

        document.getElementById('exportExcel').addEventListener('click', () => {
            if (!receiptData) {
                alert('Please scan a receipt first!');
                return;
            }

            console.log('Export Excel clicked');
            console.log('XLSX available:', typeof XLSX !== 'undefined');

            try {
                // Check if XLSX is loaded
                if (typeof XLSX === 'undefined') {
                    console.error('XLSX library not loaded');
                    alert('Excel library failed to load. Exporting as CSV instead.');
                    exportFullCSV();
                    return;
                }

                // Create workbook and worksheet
                const wb = XLSX.utils.book_new();
                
                // Prepare data with proper formatting
                const data = [
                    ['Merchant', 'Date', 'Item', 'Price']
                ];
                
                receiptData.items.forEach(item => {
                    data.push([
                        receiptData.merchant,
                        receiptData.date,
                        item.name,
                        item.price
                    ]);
                });
                
                // Add total row
                data.push([
                    receiptData.merchant,
                    receiptData.date,
                    'TOTAL',
                    receiptData.total
                ]);
                
                const ws = XLSX.utils.aoa_to_sheet(data);
                
                // Set column widths
                ws['!cols'] = [
                    { wch: 20 }, // Merchant
                    { wch: 12 }, // Date
                    { wch: 40 }, // Item
                    { wch: 12 }  // Price
                ];
                
                // Format price columns as currency
                const range = XLSX.utils.decode_range(ws['!ref']);
                for (let row = 1; row <= range.e.r; row++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: 3 }); // Column D (Price)
                    if (ws[cellAddress]) {
                        ws[cellAddress].z = '$#,##0.00'; // Currency format
                    }
                }
                
                XLSX.utils.book_append_sheet(wb, ws, 'Receipt Details');
                XLSX.writeFile(wb, 'receipt_full.xlsx');
                
                console.log('Excel export successful');
            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting Excel: ' + error.message + '. Trying CSV instead.');
                exportFullCSV();
            }
        });

        document.getElementById('exportSummaryExcel').addEventListener('click', () => {
            if (!receiptData) {
                alert('Please scan a receipt first!');
                return;
            }

            console.log('Export Summary Excel clicked');

            try {
                // Check if XLSX is loaded
                if (typeof XLSX === 'undefined') {
                    console.error('XLSX library not loaded');
                    alert('Excel library failed to load. Exporting as CSV instead.');
                    exportSummaryCSV();
                    return;
                }

                const wb = XLSX.utils.book_new();
                
                const data = [
                    ['Date', 'Merchant', 'Total'],
                    [receiptData.date, receiptData.merchant, receiptData.total]
                ];
                
                const ws = XLSX.utils.aoa_to_sheet(data);
                
                // Set column widths
                ws['!cols'] = [
                    { wch: 12 }, // Date
                    { wch: 25 }, // Merchant
                    { wch: 12 }  // Total
                ];
                
                // Format total as currency
                if (ws['C2']) {
                    ws['C2'].z = '$#,##0.00';
                }
                
                XLSX.utils.book_append_sheet(wb, ws, 'Summary');
                XLSX.writeFile(wb, 'receipt_summary.xlsx');
                
                console.log('Summary Excel export successful');
            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting Excel: ' + error.message + '. Trying CSV instead.');
                exportSummaryCSV();
            }
        });

        // Export Summary CSV button - adds quick CSV export for Date, Merchant, Total
        document.getElementById('exportSummaryCSV').addEventListener('click', () => {
            if (!receiptData) {
                alert('Please scan a receipt first!');
                return;
            }
            exportSummaryCSV();
        });

        // CSV BUTTON EVENT LISTENER - FIX #1
        document.getElementById('exportCSV').addEventListener('click', () => {
            if (!receiptData) {
                alert('Please scan a receipt first!');
                return;
            }
            exportFullCSV();
        });

        // CSV fallback functions - FIX #2: Added $ symbols
        function exportFullCSV() {
            let csv = 'Merchant,Date,Item,Price\n';
            receiptData.items.forEach(item => {
                csv += `"${receiptData.merchant}","${receiptData.date}","${item.name}","${item.price.toFixed(2)}"\n`;
            });
            csv += `"${receiptData.merchant}","${receiptData.date}","TOTAL","${receiptData.total.toFixed(2)}"`;

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'receipt_full.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportSummaryCSV() {
            let csv = 'Date,Merchant,Total\n';
            csv += `"${receiptData.date}","${receiptData.merchant}","${receiptData.total.toFixed(2)}"`;

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'receipt_summary.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        document.getElementById('copyTable').addEventListener('click', () => {
            if (!receiptData) return;

            let text = `Merchant: ${receiptData.merchant}\n`;
            text += `Date: ${receiptData.date}\n\n`;
            text += 'Items:\n';
            receiptData.items.forEach(item => {
                text += `${item.name}\t${item.price.toFixed(2)}\n`;
            });
            text += `TOTAL\t${receiptData.total.toFixed(2)}`;

            navigator.clipboard.writeText(text).then(() => {
                alert('Table copied to clipboard!');
            });
        });
    </script>
</body>
</html>
