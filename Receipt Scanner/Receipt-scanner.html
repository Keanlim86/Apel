<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Receipt Scanner</title>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- PDF.js library for rendering PDFs to canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .upload-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9ff;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            background: #e8ebff;
            border-color: #764ba2;
        }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: 600;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #imagePreview {
            max-width: 100%;
            border-radius: 10px;
            display: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .progress-container {
            display: none;
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .results-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .info-card {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .info-card h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        tr:hover {
            background: #f8f9ff;
        }

        .total-row {
            font-weight: bold;
            background: #f0f2ff;
            font-size: 1.2em;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .btn-secondary:hover {
            background: #f8f9ff;
        }

        #results {
            display: none;
        }

        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìÑ Receipt Scanner</h1>
            <p>Upload a receipt image and extract data automatically</p>
        </div>

        <div class="content">
            <div class="upload-section">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üì∏</div>
                    <h3>Drop receipt image or PDF here</h3>
                    <p>or click to select file</p>
                    <input type="file" id="fileInput" accept="image/*,application/pdf" style="display: none;">
                </div>
                
                <img id="imagePreview" alt="Receipt preview">
                
                <button class="btn" id="scanBtn" style="display: none;">Scan Receipt</button>
                
                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                </div>

                <!-- On-screen debug panel (visible when debugging) -->
                <div id="debugPanel" style="display:none; background:#111; color:#e6e6e6; padding:12px; border-radius:8px; margin-top:16px; max-height:240px; overflow:auto; font-family: monospace; font-size:13px;">
                    <strong>Debug:</strong>
                    <pre id="debugText" style="white-space:pre-wrap; margin-top:8px;"></pre>
                </div>
            </div>

            <div class="results-section" id="results">
                <div class="info-card">
                    <h3>Merchant</h3>
                    <p id="merchant">-</p>
                </div>
                
                <div class="info-card">
                    <h3>Date</h3>
                    <p id="date">-</p>
                </div>

                <div>
                    <h3 style="margin-bottom: 10px; color: #667eea;">Items</h3>
                    <table id="itemsTable">
                        <thead>
                            <tr>
                                <th>Item</th>
                                <th>Price</th>
                            </tr>
                        </thead>
                        <tbody id="itemsBody"></tbody>
                    </table>
                </div>

                <div class="export-buttons">
                    <button class="btn btn-secondary" id="exportSummaryExcel">Export Summary Excel</button>
                    <button class="btn btn-secondary" id="exportExcel">Export Full Excel</button>
                    <button class="btn btn-secondary" id="exportSummaryCSV">Export Summary CSV</button>
                    <button class="btn btn-secondary" id="exportCSV">Export Full CSV</button>
                    <button class="btn btn-secondary" id="copyTable">Copy Table</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentImage = null;
        let receiptData = null;

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const imagePreview = document.getElementById('imagePreview');
        const scanBtn = document.getElementById('scanBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const results = document.getElementById('results');
        const processingCanvas = document.createElement('canvas');
        processingCanvas.id = 'processingCanvas';
        processingCanvas.style.display = 'none';
        document.body.appendChild(processingCanvas);
        const processingCtx = processingCanvas.getContext('2d');

        // Upload area click
        uploadArea.addEventListener('click', () => fileInput.click());

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && (file.type.startsWith('image/') || file.type === 'application/pdf')) {
                handleFile(file);
            }
        });

        // File input change
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        async function handleFile(file) {
            if (file.type === 'application/pdf') {
                await handlePDF(file);
            } else {
                handleImage(file);
            }
        }

        function handleImage(file) {
            currentImage = file;
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
                scanBtn.style.display = 'block';
            };
            reader.readAsDataURL(file);
        }

        async function handlePDF(file) {
            try {
                // Check if PDF.js is loaded
                if (typeof pdfjsLib === 'undefined') {
                    alert('PDF library is still loading. Please try again in a moment.');
                    return;
                }
                
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                
                // Get first page
                const page = await pdf.getPage(1);
                const viewport = page.getViewport({ scale: 3.0 });
                
                // Create canvas
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                // Render PDF page to canvas
                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;
                
                // Auto-crop the receipt region and enhance for OCR accuracy
                const enhancedCanvas = autoCropAndEnhance(canvas, 2000);
                const blob = await new Promise(resolve => enhancedCanvas.toBlob(resolve, 'image/png'));
                currentImage = blob;
                const infoMsg = 'PDF rendered and enhanced to blob, size: ' + (blob ? blob.size : 'none') + ' enhanced dims: ' + enhancedCanvas.width + ' x ' + enhancedCanvas.height;
                console.log(infoMsg);
                setDebug(infoMsg);
                imagePreview.src = enhancedCanvas.toDataURL();
                imagePreview.style.display = 'block';
                scanBtn.style.display = 'block';
                
            } catch (error) {
                alert('Error loading PDF: ' + error.message);
                console.error('PDF Error:', error);
            }
        }

        async function prepareProcessingCanvas(source) {
            if (!source) throw new Error('No image source provided for processing canvas');

            const isCanvasSource = source instanceof HTMLCanvasElement;
            if (isCanvasSource) {
                processingCanvas.width = source.width;
                processingCanvas.height = source.height;
                processingCtx.clearRect(0, 0, source.width, source.height);
                processingCtx.drawImage(source, 0, 0);
            } else {
                const objectUrl = URL.createObjectURL(source);
                const img = new Image();
                const loadPromise = new Promise((resolve, reject) => {
                    img.onload = () => resolve();
                    img.onerror = () => reject(new Error('Failed to load image for processing canvas'));
                });
                img.src = objectUrl;
                try {
                    await loadPromise;
                } finally {
                    URL.revokeObjectURL(objectUrl);
                }

                processingCanvas.width = img.width;
                processingCanvas.height = img.height;
                processingCtx.clearRect(0, 0, img.width, img.height);
                processingCtx.drawImage(img, 0, 0);
            }

            const cropped = autoCropAndEnhance(processingCanvas, 2000);
            const processed = preprocessCanvas(cropped);
            appendDebug('Processing canvas ready (' + processed.width + ' x ' + processed.height + ')');
            return processed;
        }

        // Scan button
        scanBtn.addEventListener('click', scanReceipt);

        async function scanReceipt() {
            if (!currentImage) {
                setDebug('No image available to scan.');
                return;
            }

            setDebug('Starting scan...');
            appendDebug('Image size: ' + ((currentImage && currentImage.size) ? currentImage.size : 'n/a'));

            // Quick check that Tesseract is available
            if (typeof Tesseract === 'undefined') {
                appendDebug('Tesseract.js not loaded.');
                alert('OCR library not ready. Please refresh the page and try again.');
                return;
            }

            scanBtn.disabled = true;
            progressContainer.style.display = 'block';
            results.style.display = 'none';

            try {
                let ocrSource = currentImage;
                try {
                    ocrSource = await prepareProcessingCanvas(currentImage);
                } catch (prepError) {
                    appendDebug('Processing canvas prep failed, falling back to raw image: ' + prepError.message);
                }

                const result = await Tesseract.recognize(ocrSource, 'eng', {
                    logger: (m) => {
                        // Update progress bar and debug panel
                        if (m.status === 'recognizing text') {
                            const progress = Math.round(m.progress * 100);
                            progressFill.style.width = progress + '%';
                            progressFill.textContent = progress + '%';
                            appendDebug('OCR progress: ' + progress + '%');
                        } else {
                            appendDebug('OCR status: ' + m.status + (m.progress ? (' ' + Math.round(m.progress * 100) + '%') : ''));
                        }
                    },
                    tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz .,/$-:',
                    tessedit_pageseg_mode: Tesseract.PSM.AUTO
                });

                appendDebug('OCR raw text: ' + (result && result.data ? result.data.text : ''));
                const text = cleanOCRText(result.data.text);
                appendDebug('OCR cleaned text: ' + text);
                receiptData = parseReceipt(text);
                appendDebug('Parsed receipt: ' + JSON.stringify(receiptData));
                displayResults(receiptData);

            } catch (error) {
                appendDebug('Error scanning receipt: ' + (error && error.message ? error.message : JSON.stringify(error)));
                alert('Error scanning receipt: ' + error.message);
            } finally {
                scanBtn.disabled = false;
            }
        }

        function cleanOCRText(text) {
            // Remove common OCR artifacts and special characters
            text = text.replace(/[^\x00-\x7F]/g, ''); // Remove non-ASCII
            text = text.replace(/√Ç¬•|√Ç¬´|√Ç¬ª|√Ç¬Æ|√Ç¬©|√Ç¬∞/g, ''); // Remove specific artifacts
            text = text.replace(/[|~`^]/g, ''); // Remove confusing symbols
            
            // Fix common OCR letter confusion for Singapore merchants
            // Isetan
            text = text.replace(/\bT SINGAPORE\b/gi, 'ISETAN SINGAPORE');
            text = text.replace(/\bTSETAN\b/gi, 'ISETAN');
            text = text.replace(/\b1SETAN\b/gi, 'ISETAN');
            text = text.replace(/\bISETAN\b/gi, 'ISETAN');
            
            // FairPrice variations
            text = text.replace(/\bFa1rpr1ce\b/gi, 'FAIRPRICE');
            text = text.replace(/\bFa1rprice\b/gi, 'FAIRPRICE');
            text = text.replace(/\bFairpr1ce\b/gi, 'FAIRPRICE');
            text = text.replace(/\bFair Pr1ce\b/gi, 'FAIRPRICE');
            text = text.replace(/\bNTUC\s*Fa1rprice\b/gi, 'NTUC FAIRPRICE');
            
            // Cold Storage
            text = text.replace(/\bC0LD\s*ST0RAGE\b/gi, 'COLD STORAGE');
            text = text.replace(/\bC0LDSTORAGE\b/gi, 'COLD STORAGE');
            text = text.replace(/\bCOLD\s*ST0RAGE\b/gi, 'COLD STORAGE');
            text = text.replace(/\bC0LD\s*STORAGE\b/gi, 'COLD STORAGE');
            
            // Giant
            text = text.replace(/\bG1ANT\b/gi, 'GIANT');
            text = text.replace(/\bGlANT\b/gi, 'GIANT');
            
            // Sheng Siong
            text = text.replace(/\bSHENG\s*S10NG\b/gi, 'SHENG SIONG');
            text = text.replace(/\bSHENG\s*SlONG\b/gi, 'SHENG SIONG');
            
            // Prime / Cheers / 7-Eleven
            text = text.replace(/\bPR1ME\b/gi, 'PRIME');
            text = text.replace(/\bCHEERS\b/gi, 'CHEERS');
            text = text.replace(/\b7-ELEVEN\b/gi, '7-ELEVEN');
            text = text.replace(/\b7-ELEVEtl\b/gi, '7-ELEVEN');
            text = text.replace(/\b7\s*ELEVEN\b/gi, '7-ELEVEN');
            
            // Don Don Donki
            text = text.replace(/\bD0N\s*D0N\s*D0NKI\b/gi, 'DON DON DONKI');
            text = text.replace(/\bDON\s*DON\s*D0NKI\b/gi, 'DON DON DONKI');
            text = text.replace(/\bD0NK1\b/gi, 'DONKI');
            
            // Guardian / Watsons
            text = text.replace(/\bGUARD1AN\b/gi, 'GUARDIAN');
            text = text.replace(/\bWATS0NS\b/gi, 'WATSONS');
            text = text.replace(/\bWATSONS\b/gi, 'WATSONS');
            
            // Popular / Courts
            text = text.replace(/\bP0PULAR\b/gi, 'POPULAR');
            text = text.replace(/\bC0URTS\b/gi, 'COURTS');
            
            // McDonald's / KFC / Burger King
            text = text.replace(/\bMcD0NALD'?S\b/gi, 'MCDONALDS');
            text = text.replace(/\bMCDONALD'?S\b/gi, 'MCDONALDS');
            text = text.replace(/\bKFC\b/gi, 'KFC');
            text = text.replace(/\bBURGER\s*K1NG\b/gi, 'BURGER KING');
            
            // Uniqlo / Muji / Daiso
            text = text.replace(/\bUN1QLO\b/gi, 'UNIQLO');
            text = text.replace(/\bUNIQL0\b/gi, 'UNIQLO');
            text = text.replace(/\bMUJ1\b/gi, 'MUJI');
            text = text.replace(/\bDA1SO\b/gi, 'DAISO');
            text = text.replace(/\bDAIS0\b/gi, 'DAISO');
            
            // Try to fix chunked text by detecting price patterns and adding line breaks
            // Add line break before prices that look like: 1.23 or $1.23 or 12.34
            text.replace(/(\d+\.\d{2})(?=\s+[A-Z])/g, '$1\n');
            
            // Add line break before common quantity patterns: 1pcs, 2x, 1kg
            text = text.replace(/\s+(\d+(?:pcs|pc|x|kg|g|ml|l)\b)/gi, '\n$1 ');
            
            // Add line break before "Description" and similar headers
            text = text.replace(/(Description|Item|Product|Qty)/gi, '\n$1');
            
            // Add line break before parentheses that often indicate new items
            text = text.replace(/\)\s+([A-Z])/g, ')\n$1');
            
            // Normalize multiple spaces but preserve line breaks
            text = text.replace(/ +/g, ' ');
            text = text.replace(/\n\s+/g, '\n');
            
            return text;
        }

        function normalizeMerchant(merchant, fullText) {
            // Normalize common merchant OCR variants using heuristics
            const t = (fullText || '').toUpperCase();
            let normalized = merchant;

            // ISETAN variants seen in OCR: ISETAN, TSETAN, 1SETAN, IBETAN, IBETaN (from PDFs)
            if (/ISETAN|TSETAN|1SETAN|IBETAN|I\s*B\s*E\s*T\s*A\s*N/gi.test(t)) {
                normalized = /SINGAPORE/i.test(t) ? 'ISETAN SINGAPORE' : 'ISETAN';
            }

            // If merchant was just 'SINGAPORE' but text contains ISETAN-like tokens, prefer the full name
            if (/^SINGAPORE$/i.test(merchant) && /ISETAN|TSETAN|1SETAN|IBETAN/i.test(t)) {
                normalized = 'ISETAN SINGAPORE';
            }

            if (normalized !== merchant) console.log('Merchant normalized from', merchant, 'to', normalized);
            return normalized;
        }

        function parseReceipt(text) {
            let lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 2);

            const items = [];
            let total = 0;
            let subtotal = 0;
            let date = '';
            let merchant = '';

            // -------------------------------
            // 1Ô∏è‚É£ Find merchant (first 5 lines, mostly letters)
            // -------------------------------
            for (let i = 0; i < Math.min(5, lines.length); i++) {
                const line = lines[i];
                const letterCount = (line.match(/[a-zA-Z]/g) || []).length;
                const digitCount = (line.match(/\d/g) || []).length;
                if (letterCount > 3 && letterCount > digitCount * 2) {
                    merchant = line;
                    break;
                }
            }

            // -------------------------------
            // 2Ô∏è‚É£ Find date
            // -------------------------------
            const datePatterns = [
                /\b(\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4})\b/,
                /\b(\d{4}[-\/]\d{1,2}[-\/]\d{1,2})\b/,
                /\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2},?\s+\d{4}\b/i,
                /Date[:\s]*(\d{1,2}\/\d{1,2}\/\d{2,4})/i
            ];
            for (const line of lines) {
                for (const pattern of datePatterns) {
                    const match = line.match(pattern);
                    if (match) {
                        date = match[1] || match[0];
                        break;
                    }
                }
                if (date) break;
            }

            // -------------------------------
            // 3Ô∏è‚É£ Parse items and prices
            // -------------------------------
            const pricePattern = /\$?\s*(\d+\.\d{2})\b/g;
            const subtotalPattern = /\bsub[\s-]?to?t?a?l\b/i; // fuzzy subtotal
            const totalPattern = /\btotal\b/i;
            const taxPattern = /\b(G[S5]T|G5T|GST|65T|included|incl)\b/i; // fuzzy GST/tax
            const servicePattern = /\b(dine\s*in|take\s*away|takeaway|eat\s*in|delivery|self\s*pickup)\b/i;
            let tax = 0;

            let skipNext = false;

            for (let i = 0; i < lines.length; i++) {
                if (skipNext) {
                    skipNext = false;
                    continue;
                }

                const line = lines[i];
                const lowerLine = line.toLowerCase();

                // Skip headers/footers
                if (/(tel:|reg\. no|gst|staff:|slip:|pos )/i.test(lowerLine)) continue;

                // Skip service-mode lines
                if (servicePattern.test(lowerLine)) continue;
                
                const matches = [...line.matchAll(pricePattern)];
                const hasPrice = matches.length > 0;

                // Handle split items: current line no price, next line has price
                if (!hasPrice && i < lines.length - 1) {
                    const nextLine = lines[i + 1];
                    const nextMatches = [...nextLine.matchAll(pricePattern)];
                    if (nextMatches.length > 0) {
                        const price = parseFloat(nextMatches[nextMatches.length - 1][1].replace(',', '.'));
                        let itemName = line.replace(/\d+\.?\d*\s*(pcs|pc|x|kg|g|ml|l|pkt)?/gi, '').trim();
                        if (itemName && price > 0) {
                            items.push({ name: itemName, price });
                            skipNext = true;
                            continue;
                        }
                    }
                }

                if (hasPrice) {
                    const price = parseFloat(matches[matches.length - 1][1].replace(',', '.'));

                    // -------------------------------
                    // 3aÔ∏è‚É£ GST / tax detection
                    // -------------------------------
                    if (taxPattern.test(lowerLine)) {
                        gst = price;  // capture GST/tax separately
                        continue;     // do not add as item
                    }

                    // -------------------------------
                    // 3bÔ∏è‚É£ Fuzzy subtotal detection
                    // -------------------------------
                    if (subtotalPattern.test(lowerLine)) {
                        subtotal = price;
                        continue;
                    }

                    // -------------------------------
                    // 3cÔ∏è‚É£ Total detection (ignore subtotal)
                    // -------------------------------
                    if (totalPattern.test(lowerLine) && !subtotalPattern.test(lowerLine)) {
                        total = price;
                        continue;
                    }

                    // -------------------------------
                    // 3dÔ∏è‚É£ Skip non-item lines
                    // -------------------------------
                    if (/(tax|change|cash|card|tender)/i.test(lowerLine)) continue;

                    // -------------------------------
                    // 3eÔ∏è‚É£ Add item
                    // -------------------------------
                    let itemName = line.replace(pricePattern, '').replace(/\d+\.?\d*\s*(pcs|pc|x|kg|g|ml|l|pkt)?/gi, '').trim();
                    if (itemName && price > 0) {
                        const digitRatio = (itemName.match(/\d/g) || []).length / itemName.length;
                        if (digitRatio < 0.7) {
                            items.push({ name: itemName, price });
                        }
                    }
                }
            }

            // -------------------------------
            // 4Ô∏è‚É£ Ensure total is reasonable
            // -------------------------------
            // (no changes here)

            // -------------------------------
            // 5Ô∏è‚É£ Return parsed receipt
            // -------------------------------
            return { merchant, date, items, subtotal, gst, total };
        }

        function cleanItemName(itemName) {
            // Remove SKU numbers (patterns like: 123456, 12-3456, SKU123456, #123456)
            itemName = itemName.replace(/\b\d{5,}\b/g, ''); // 5+ consecutive digits
            itemName = itemName.replace(/\b\d{2,}-\d{2,}\b/g, ''); // Format like 12-3456
            itemName = itemName.replace(/\bsku\s*:?\s*\d+/gi, ''); // SKU: 123456
            itemName = itemName.replace(/\b#\d{4,}\b/g, ''); // #123456
            itemName = itemName.replace(/\bitem\s*:?\s*\d+/gi, ''); // Item: 123456
            itemName = itemName.replace(/\bcode\s*:?\s*\d+/gi, ''); // Code: 123456
            
            // Clean up item name - only remove specific leading/trailing characters
            // Keep parentheses, but remove dashes, underscores, asterisks at start/end
            itemName = itemName.replace(/^[-_*.\s]+|[-_*.\s]+$/g, '');
            itemName = itemName.replace(/\s+/g, ' '); // Normalize spaces
            itemName = itemName.trim();
            
            return itemName;
        }

        // Auto-crop small receipt regions and enhance contrast before OCR
        function autoCropAndEnhance(sourceCanvas, targetWidth = 2000) {
            const sw = sourceCanvas.width, sh = sourceCanvas.height;
            const ctx = sourceCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, sw, sh);
            const data = imageData.data;

            // Find bounding box of non-white pixels (sample every 3 pixels for speed)
            let minX = sw, minY = sh, maxX = 0, maxY = 0;
            const sample = 3;
            const threshold = 240; // brightness threshold (0-255)

            for (let y = 0; y < sh; y += sample) {
                for (let x = 0; x < sw; x += sample) {
                    const i = (y * sw + x) * 4;
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                    if (lum < threshold) {
                        if (x < minX) minX = x;
                        if (y < minY) minY = y;
                        if (x > maxX) maxX = x;
                        if (y > maxY) maxY = y;
                    }
                }
            }

            // If nothing detected, return original canvas
            if (maxX === 0 && maxY === 0) {
                console.log('autoCropAndEnhance: no content detected; skipping crop.');
                return sourceCanvas;
            }

            // Add padding
            const padding = Math.round(Math.min(sw, sh) * 0.03) + 20;
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(sw, maxX + padding);
            maxY = Math.min(sh, maxY + padding);

            const cw = maxX - minX;
            const ch = maxY - minY;

            // Determine scale to reach targetWidth (but cap to avoid huge canvases)
            const capWidth = 3000; // increase cap to allow better upscaling if needed
            let scale = 1;
            if (cw > 0 && cw < targetWidth) scale = targetWidth / cw;
            const dw = Math.min(Math.round(cw * scale), capWidth);
            const dh = Math.round(ch * (dw / cw));

            const dest = document.createElement('canvas');
            dest.width = dw;
            dest.height = dh;
            const dctx = dest.getContext('2d');
            dctx.imageSmoothingEnabled = true;
            dctx.imageSmoothingQuality = 'high';

            // Apply simple enhancements: make grayscale and boost contrast slightly
            dctx.filter = 'grayscale(100%) contrast(120%)';
            dctx.drawImage(sourceCanvas, minX, minY, cw, ch, 0, 0, dw, dh);
            dctx.filter = 'none';

            console.log('autoCropAndEnhance: cropped to', cw, 'x', ch, 'and scaled to', dw, 'x', dh);
            return dest;
        }

        // Preprocessing: sharpen and binarize to improve OCR accuracy for low-res receipts
        function preprocessCanvas(canvas) {
            const w = canvas.width, h = canvas.height;
            const ctx = canvas.getContext('2d');
            let imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;

            // Convert to grayscale
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                const l = Math.round(0.2126*r + 0.7152*g + 0.0722*b);
                data[i] = data[i+1] = data[i+2] = l;
            }

            // Apply simple sharpen filter via convolution kernel
            const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
            const output = new Uint8ClampedArray(data.length);
            for (let y = 1; y < h-1; y++) {
                for (let x = 1; x < w-1; x++) {
                    let sum = 0;
                    let ki = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const px = x + kx;
                            const py = y + ky;
                            const idx = (py * w + px) * 4;
                            sum += data[idx] * kernel[ki++];
                        }
                    }
                    const dstIdx = (y * w + x) * 4;
                    const v = Math.max(0, Math.min(255, sum));
                    output[dstIdx] = output[dstIdx+1] = output[dstIdx+2] = v;
                    output[dstIdx+3] = 255;
                }
            }

            // Copy edges if any (simple copy to avoid zeros)
            for (let x = 0; x < w; x++) {
                const top = x * 4;
                const bottom = ((h-1) * w + x) * 4;
                output[top] = data[top]; output[top+1] = data[top+1]; output[top+2] = data[top+2]; output[top+3] = 255;
                output[bottom] = data[bottom]; output[bottom+1] = data[bottom+1]; output[bottom+2] = data[bottom+2]; output[bottom+3] = 255;
            }
            for (let y = 0; y < h; y++) {
                const left = (y * w) * 4;
                const right = (y * w + (w-1)) * 4;
                output[left] = data[left]; output[left+1] = data[left+1]; output[left+2] = data[left+2]; output[left+3] = 255;
                output[right] = data[right]; output[right+1] = data[right+1]; output[right+2] = data[right+2]; output[right+3] = 255;
            }

            // Put sharpened data back
            imgData.data.set(output);

            // Compute global Otsu threshold
            const histogram = new Array(256).fill(0);
            for (let i = 0; i < output.length; i += 4) histogram[output[i]]++;
            const total = w * h;
            let sum = 0;
            for (let t = 0; t < 256; t++) sum += t * histogram[t];
            let sumB = 0;
            let wB = 0;
            let maxVar = 0;
            let threshold = 128;
            for (let t = 0; t < 256; t++) {
                wB += histogram[t];
                if (wB === 0) continue;
                const wF = total - wB;
                if (wF === 0) break;
                sumB += t * histogram[t];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                const varBetween = wB * wF * Math.pow(mB - mF, 2);
                if (varBetween > maxVar) {
                    maxVar = varBetween;
                    threshold = t;
                }
            }

            // Apply threshold
            for (let i = 0; i < output.length; i += 4) {
                const v = output[i] >= threshold ? 255 : 0;
                output[i] = output[i+1] = output[i+2] = v;
                output[i+3] = 255;
            }

            imgData.data.set(output);
            ctx.putImageData(imgData, 0, 0);

            console.log('preprocessCanvas: applied sharpen + otsu threshold (t=' + threshold + ')');
            return canvas;
        }

        // Debug helpers
        function setDebug(msg) {
            const panel = document.getElementById('debugPanel');
            const text = document.getElementById('debugText');
            if (!panel || !text) return;
            panel.style.display = 'block';
            text.textContent = msg;
        }

        function appendDebug(msg) {
            const panel = document.getElementById('debugPanel');
            const text = document.getElementById('debugText');
            if (!panel || !text) return;
            panel.style.display = 'block';
            text.textContent += (text.textContent ? '\n' : '') + msg;
        }

        function displayResults(data) {
            document.getElementById('merchant').textContent = data.merchant;
            document.getElementById('date').textContent = data.date;

            const tbody = document.getElementById('itemsBody');
            tbody.innerHTML = '';

            data.items.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = item.name;
                row.insertCell(1).textContent = '$' + item.price.toFixed(2);
            });

            // Subtotal  (Optional)
            if (data.subtotal && data.subtotal > 0) {
                const subRow = tbody.insertRow();
                subRow.insertCell(0).textContent = 'Subtotal';
                subRow.insertCell(1).textContent = '$' + data.subtotal.toFixed(2);
            }

            // GST (Optional)
            if (data.gst && data.gst > 0) {
                const gstRow = tbody.insertRow();
                gstRow.insertCell(0).textContent = 'GST';
                gstRow.insertCell(1).textContent = '$' + data.gst.toFixed(2);
            }

            // TOTAL
            const totalRow = tbody.insertRow();
            totalRow.className = 'total-row';
            totalRow.insertCell(0).textContent = 'TOTAL';
            totalRow.insertCell(1).textContent = '$' + data.total.toFixed(2);

            // If the total differs significantly from the sum of items, notify the user
            const itemsSum = data.items.reduce((s, it) => s + it.price, 0);
            if (Math.abs(itemsSum - data.total) > 0.01) {
                appendDebug('Note: total adjusted to $' + data.total.toFixed(2) + ' (items sum: $' + itemsSum.toFixed(2) + ').');
            }

            results.style.display = 'flex';
            progressContainer.style.display = 'none';
        }

        document.getElementById('exportExcel').addEventListener('click', () => {
            if (!receiptData) {
                alert('Please scan a receipt first!');
                return;
            }

            console.log('Export Excel clicked');
            console.log('XLSX available:', typeof XLSX !== 'undefined');

            try {
                // Check if XLSX is loaded
                if (typeof XLSX === 'undefined') {
                    console.error('XLSX library not loaded');
                    alert('Excel library failed to load. Exporting as CSV instead.');
                    exportFullCSV();
                    return;
                }

                // Create workbook and worksheet
                const wb = XLSX.utils.book_new();
                
                // Prepare data with proper formatting
                const data = [
                    ['Merchant', 'Date', 'Item', 'Price']
                ];
                
                receiptData.items.forEach(item => {
                    data.push([
                        receiptData.merchant,
                        receiptData.date,
                        item.name,
                        item.price
                    ]);
                });
                
                // Add total row
                data.push([
                    receiptData.merchant,
                    receiptData.date,
                    'TOTAL',
                    receiptData.total
                ]);
                
                const ws = XLSX.utils.aoa_to_sheet(data);
                
                // Set column widths
                ws['!cols'] = [
                    { wch: 20 }, // Merchant
                    { wch: 12 }, // Date
                    { wch: 40 }, // Item
                    { wch: 12 }  // Price
                ];
                
                // Format price columns as currency
                const range = XLSX.utils.decode_range(ws['!ref']);
                for (let row = 1; row <= range.e.r; row++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: 3 }); // Column D (Price)
                    if (ws[cellAddress]) {
                        ws[cellAddress].z = '$#,##0.00'; // Currency format
                    }
                }
                
                XLSX.utils.book_append_sheet(wb, ws, 'Receipt Details');
                XLSX.writeFile(wb, 'receipt_full.xlsx');
                
                console.log('Excel export successful');
            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting Excel: ' + error.message + '. Trying CSV instead.');
                exportFullCSV();
            }
        });

        document.getElementById('exportSummaryExcel').addEventListener('click', () => {
            if (!receiptData) {
                alert('Please scan a receipt first!');
                return;
            }

            console.log('Export Summary Excel clicked');

            try {
                // Check if XLSX is loaded
                if (typeof XLSX === 'undefined') {
                    console.error('XLSX library not loaded');
                    alert('Excel library failed to load. Exporting as CSV instead.');
                    exportSummaryCSV();
                    return;
                }

                const wb = XLSX.utils.book_new();
                
                const data = [
                    ['Date', 'Merchant', 'Total'],
                    [receiptData.date, receiptData.merchant, receiptData.total]
                ];
                
                const ws = XLSX.utils.aoa_to_sheet(data);
                
                // Set column widths
                ws['!cols'] = [
                    { wch: 12 }, // Date
                    { wch: 25 }, // Merchant
                    { wch: 12 }  // Total
                ];
                
                // Format total as currency
                if (ws['C2']) {
                    ws['C2'].z = '$#,##0.00';
                }
                
                XLSX.utils.book_append_sheet(wb, ws, 'Summary');
                XLSX.writeFile(wb, 'receipt_summary.xlsx');
                
                console.log('Summary Excel export successful');
            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting Excel: ' + error.message + '. Trying CSV instead.');
                exportSummaryCSV();
            }
        });

        // Export Summary CSV button - adds quick CSV export for Date, Merchant, Total
        document.getElementById('exportSummaryCSV').addEventListener('click', () => {
            if (!receiptData) {
                alert('Please scan a receipt first!');
                return;
            }
            exportSummaryCSV();
        });

        // CSV BUTTON EVENT LISTENER - FIX #1
        document.getElementById('exportCSV').addEventListener('click', () => {
            if (!receiptData) {
                alert('Please scan a receipt first!');
                return;
            }
            exportFullCSV();
        });

        // CSV fallback functions - FIX #2: Added $ symbols
        function exportFullCSV() {
            let csv = 'Merchant,Date,Item,Price\n';
            receiptData.items.forEach(item => {
                csv += `"${receiptData.merchant}","${receiptData.date}","${item.name}","${item.price.toFixed(2)}"\n`;
            });
            csv += `"${receiptData.merchant}","${receiptData.date}","TOTAL","${receiptData.total.toFixed(2)}"`;

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'receipt_full.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportSummaryCSV() {
            let csv = 'Date,Merchant,Total\n';
            csv += `"${receiptData.date}","${receiptData.merchant}","${receiptData.total.toFixed(2)}"`;

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'receipt_summary.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        document.getElementById('copyTable').addEventListener('click', () => {
            if (!receiptData) return;

            let text = `Merchant: ${receiptData.merchant}\n`;
            text += `Date: ${receiptData.date}\n\n`;
            text += 'Items:\n';
            receiptData.items.forEach(item => {
                text += `${item.name}\t${item.price.toFixed(2)}\n`;
            });
            text += `TOTAL\t${receiptData.total.toFixed(2)}`;

            navigator.clipboard.writeText(text).then(() => {
                alert('Table copied to clipboard!');
            });
        });
    </script>
</body>
</html>
